[/
 / Copyright 2013 OptionMetrics, Inc.
 / Copyright 2013 Eric Niebler
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[library QuickCheckCpp
    [quickbook 1.3]
    [authors [Niebler, Eric]]
    [copyright 2013 Eric Niebler]
    [category testing]
    [id quick_check]
    [dirname quick_check]
    [purpose
        Quickly test your algorithms by automatically generating
        input and verifying properties of the output.
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.3 ]

[/ Substitutions ]

[def __qchk__                QuickCheckCpp]
[def __note__                [$images/note.png]]
[def __alert__               [$images/caution.png]]
[def __detail__              [$images/note.png]]
[def __tip__                 [$images/tip.png]]
[def __qcheck__              [^[funcref quick_check::qcheck()]]]
[def __classify__            [^[funcref quick_check::classify()]]]
[def __group_by__            [^[funcref quick_check::group_by()]]]

[/ Imports ]

[import ../example/simple.cpp]
[import ../example/complex.cpp]
[import ../example/bind.cpp]
[import ../example/classifiers.cpp]
[import ../example/group_by.cpp]
[import ../example/condition.cpp]

[section:users_guide Users' Guide]

This section describes how to use __qchk__ to quickly sanity-check your algorithms. If you are looking for detailed information regarding specific components in __qchk__, check the [link quick_check.reference Reference] section.

[section:preface Preface]

__qchk__ is a library for [@http://en.wikipedia.org/wiki/Ad_hoc_testing ad hoc software testing]. With __qchk__, you define /properties/ of your algorithm -- predicates that must be true -- and __qchk__ does the rest, automatically generating random input data and validating that the properties hold. __qchk__ is good for quickly getting broad test coverage of your algorithms and for testing how your code behaves with unexpected input. Since __qchk__ cannot know your code's important boundary cases, it is /not/ a complete replacement for hand-crafted unit tests.

[endsect] [/ Preface]

[section:quick_start Quick Start]

Below are some simple examples to get you started quickly using __qchk__.

[heading A simple example]

The following is the most very basic example of __qchk__. It shows a very simple property being tested, with __qchk__ picking all the defaults for us.

[SimpleExample]

The above code displays:

[pre
OK, passed 100 tests.
]

[heading A more complicated example]

The following example shows most of the features of __qchk__. It uses a custom random number generator; a normal and a uniform distribution for input; user-specified configuration parameters; and a property with classifiers, grouping, and a condition.

[ComplexExample]

The above code displays:

[pre
Arguments exhausted after 7382 tests.
17% 0, bar.
17% 0, foo.
16% 1, bar.
17% 1, foo.
16% 2, bar.
16% 2, foo.
]

The __qcheck__ algorithm very much wants to execute 10,000 tests. As it turns out, only 7,382 tests satisfy the property's condition (`_2 > 0`) before the maximum number of generated tests (15,000) is reached. The result summary shows the breakdown of the generated input arguments. For instance, for 17% of the generated test cases, `_1 % 3` is 0 and `_1 <= 3` is true. We can use the summary information to reassure ourselves that we're getting the test coverage we were expecting.

[endsect] [/ Quick Start]

[section:properties Defining Properties]

This section describes how to define the properties that will be checked by the __qcheck__ algorithm.

[section:simple Simple Properties]

At its simplest, a __qchk__ property is just a Boolean [@http://www.boost.org/libs/phoenix Phoenix] lambda function. So, for instance, this is a valid __qchk__ property:

    using namespace quick_check;
    auto my_property = _1 + _2 == _2 + _1;

The above property checks that adding the second argument to the first is the same as adding the first argument to the second. This will be true for numbers, but not strings, for instance. For convenience, the Phoenix argument placeholders (`_1`, `_2`, etc.) have been imported into the `quick_check` namespace.

[endsect] [/ Simple Properties]

[section:functions Calling User-Defined Functions]

Very few interesting properties can be definied entirely with Phoenix primitives. It's often necessary to put some of the property definition in an ordinary C++ function that then gets called from Phoenix. Imagine we have a function like the following:

    namespace my_library
    {
        template<typename A, typename B>
        bool is_reflexive(A a, B b)
        {
            return (a + b) == (b + a);
        }
    }

We want to turn this (rather uninteresting) algorithm into a property we can test with __qcheck__. Ideally, we would just do this:

    // ERROR: DON'T DO THIS. It does work.
    auto is_reflex_prop = is_reflexive(_1, _2);
    
The problem is that the `is_reflexive` function template is not written to handle being passed argument placeholders. This code will fail to compile. Fortunately, the Boost.Phoenix library provides an easy solution: [@http://www.boost.org/libs/phoenix/doc/html/phoenix/starter_kit/lazy_functions.html `boost::phoenix::function`].

Here is an example:

[BindExample]

To call some function `my_library::is_reflexive` from a property, first we define a [@http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/functional/concepts/poly.html function object] `is_reflexive_impl`, which does nothing more than call `my_library::is_reflexive`. Then, we use `quick_check::function` (which is an alias for `boost::phoenix::function`) to turn the function object into a lazy function. Lazy functions are functions that know how to handle argument placeholders.

[endsect] [/ Calling User-Defined Functions]

[section:classify Classifying Input]

Since __qchk__ automatically generates input for you, you don't normally get a chance to examine the input. If you are the kind to lie awake at night wondering whether your code is getting tested with an appropriately broad set of inputs, then __qchk__ classifiers are for you. With classifiers, you can get feedback about the kind of input your code is being tested with. For instance, you may want to know that your algorithm is being tested with negative numbers in addition to positive ones. You could define your property with the __classify__ function, as follows:

[ClassifierExample]

If we test this property with some standard generators, we get the following output:

[pre
OK, passed 100 tests.
58% non-positive.
42% positive.
]

Whew! We're getting the coverage we expected.

It's possible for a set of input parameters to satisfy more than one classifier. In that case, the summary reports how many are in one class, how many are in the other, and how many are in both.

Input classification may be used in conjunction with input [link quick_check.users_guide.properties.group_by grouping] (described next).

[endsect] [/ Classifying Input]

[section:group_by Grouping Input]

In the [link quick_check.users_guide.properties.classify ["Classifying Input]] section, we saw one way of collecting statistics about the input to our properties. The __group_by__ primitive gives us another way. Say, for instance, we want to group input according to the modulus of the first argument with 3. We can do that easily as follows:

[GroupByExample]

If we test this property with some standard generators, we get the following output:

[pre
OK, passed 100 tests.
39% 0.
34% 1.
27% 2.
]

The test summary shows that the input is fairly evenly divided into thirds by the group-by condition.

A property may have only one `group_by` clause. `group_by` may be used in conjunction with [link quick_check.users_guide.properties.classify classifiers]. If so, the `group_by` clause must preceed the classifiers.

[endsect] [/ Grouping Input]

[section:conditional Conditional Evaluation]

Sometimes we want to test an algorithm that requires something of its input. For instance, if we were testing a square root algorithm, we wouldn't want to test it with negative numbers. We can use a Boolean predicate together with __qchk__'s `>>=` operator to guard our property. By guarding the property, we prevent it from ever running on bogus input. Consider the following:

[ConditionExample]

It's wrong to call `std::sqrt` with a negative number, so we have guarded our test with `(_1 > 0) >>=`. Did we write this test correctly? Let's see:

[pre
Falsifiable, after 111 tests:
[2.08687\]
]

Whoops! Our test is bogus. __qchk__ disabuses us of our naive notions about the behavior of floating point numbers. Squaring the result of `std::sqrt` doesn't quite get us back where we started, or even within `DBL_EPSILON` of where we started. The first input that caused our test to fail was `2.08687`. Thank you, __qchk__. Clearly, we need to be smarter about how to test floating point algorithms.

[endsect] [/ Conditional Evaluation]

[section:property The `property` Object]

TODO

[endsect] [/ The `property` object]

[endsect] [/ Defining Properties]

[section:config Test Configuration]

TODO

[section:generators Generating Input]

TODO

[section:primitive_types Primitive Types]

TODO Normal and uniform distributions of integral and floating point.

[endsect] [/ Primitive Types]

[section:sequences Ordered and Unordered Sequences]

TODO

[endsect] [/ Ordered and Unordered Sequences]

[section:class_types User-Defined Types]

TODO

[endsect] [/ User-Defined Types]

[endsect] [/ Generating Input]

[section:config_params Configuration Paramters]

TODO Describe _rng, _test_count, _max_test_count, and _sized.

[endsect] [/ Configuration Paramters]

[endsect] [/ Test Configuration]

[section:qcheck Running The Tests]

TODO

[section:qcheck The `qcheck` Algorithm]

TODO

[endsect] [/The `qcheck` Algorithm]

[section:qcheck Examining The Results]

TODO

[endsect] [/Examining The Results]

[endsect] [/Running The Tests]

[endsect] [/ Users' Guide]

[xinclude autodoc.xml]
