[/
 / Copyright 2013 OptionMetrics, Inc.
 / Copyright 2013 Eric Niebler
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[library QuickCheckCpp
    [quickbook 1.3]
    [authors [Niebler, Eric]]
    [copyright 2013 Eric Niebler]
    [category testing]
    [id quick_check]
    [dirname quick_check]
    [purpose
        Quickly test your algorithms by automatically generating
        input and verifying properties of the output.
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.3 ]

[/ Substitutions ]

[def __qchk__                QuickCheckCpp]
[def __note__                [$images/note.png]]
[def __alert__               [$images/caution.png]]
[def __detail__              [$images/note.png]]
[def __tip__                 [$images/tip.png]]
[def __qcheck__              [^[funcref quick_check::qcheck()]]]

[/ Imports ]

[import ../example/simple.cpp]
[import ../example/complex.cpp]
[import ../example/bind.cpp]

[section:users_guide Users' Guide]

This section describes how to use __qchk__ to quickly sanity-check your algorithms. If you are looking for detailed information regarding specific components in __qchk__, check the [link quick_check.reference Reference] section.

[section:preface Preface]

__qchk__ is a library for [@http://en.wikipedia.org/wiki/Ad_hoc_testing ad hoc software testing]. With __qchk__, you define /properties/ of your algorithm -- predicates that must be true -- and __qchk__ does the rest, automatically generating random input data and validating that the properties hold. __qchk__ is good for quickly getting broad test coverage of your algorithms and for testing how your code behaves with unexpected input. Since __qchk__ cannot know your code's important boundary cases, it is /not/ a complete replacement for hand-crafted unit tests.

[endsect] [/ Preface]

[section:quick_start Quick Start]

Below are some simple examples to get you started quickly using __qchk__.

[heading A simple example]

The following is the most very basic example of __qchk__. It shows a very simple property being tested, with __qchk__ picking all the defaults for us.

[SimpleExample]

The above code displays:

[pre
OK, passed 100 tests.
]

[heading A more complicated example]

The following example shows most of the features of __qchk__. It uses a custom random number generator; a normal and a uniform distribution for input; user-specified configuration parameters; and a property with classifiers, grouping, and a condition.

[ComplexExample]

The above code displays:

[pre
Arguments exhausted after 7382 tests.
17% 0, bar.
17% 0, foo.
16% 1, bar.
17% 1, foo.
16% 2, bar.
16% 2, foo.
]

The __qcheck__ algorithm very much wants to execute 10,000 tests. As it turns out, only 7,382 tests satisfy the property's condition (`_2 > 0`) before the maximum number of generated tests (15,000) is reached. The result summary shows the breakdown of the generated input arguments. For instance, for 17% of the generated test cases, `_1 % 3` is 0 and `_1 <= 3` is true. We can use the summary information to reassure ourselves that we're getting the test coverage we were expecting.

[endsect] [/ Quick Start]

[section:properties Defining Properties]

This section describes how to define the properties that will be checked by the __qcheck__ algorithm.

[section:simple Simple Properties]

At its simplest, a __qchk__ property is just a Boolean [@http://www.boost.org/libs/phoenix Phoenix] lambda function. So, for instance, this is a valid __qchk__ property:

    using namespace quick_check;
    auto my_property = _1 + _2 == _2 + _1;

The above property checks that adding the second argument to the first is the same as adding the first argument to the second. This will be true for numbers, but not strings, for instance. For convenience, the Phoenix argument placeholders (`_1`, `_2`, etc.) have been imported into the `quick_check` namespace.

[endsect] [/ Simple Properties]

[section:functions Calling User-Defined Functions]

Very few interesting properties can be definied entirely with Phoenix primitives. It's often necessary to put some of the property definition in an ordinary C++ function that then gets called from Phoenix. Imagine we have a function like the following:

    namespace my_library
    {
        template<typename A, typename B>
        bool is_reflexive(A a, B b)
        {
            return (a + b) == (b + a);
        }
    }

We want to turn this (rather uninteresting) algorithm into a property we can test with __qcheck__. Ideally, we would just do this:

    // ERROR: DON'T DO THIS. It does work.
    auto is_reflex_prop = is_reflexive(_1, _2);
    
The problem is that the `is_reflexive` function template is not written to handle being passed argument placeholders. This code will fail to compile. Fortunately, the Boost.Phoenix library provides an easy solution: [@http://www.boost.org/libs/phoenix/doc/html/phoenix/starter_kit/lazy_functions.html `boost::phoenix::function`].

Here is an example:

[BindExample]

To call some function `my_library::is_reflexive` from a property, first we define a [@http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/functional/concepts/poly.html function object] `is_reflexive_impl`, which does nothing more than call `my_library::is_reflexive`. Then, we use `quick_check::function` (which is an alias for `boost::phoenix::function`) to turn the function object into a lazy function. Lazy functions are functions that know how to handle argument placeholders.

[endsect] [/ Calling User-Defined Functions]

[section:basic Classifying Input]

TODO

[endsect] [/ Classifying Input]

[section:basic Grouping Input]

TODO

[endsect] [/ Grouping Input]

[section:basic Conditional Evaluation]

TODO

[endsect] [/ Conditional Evaluation]

[section:property The `property` Object]

TODO

[endsect] [/ The `property` object]

[endsect] [/ Defining Properties]

[section:config Test Configuration]

TODO

[section:generators Generating Input]

TODO

[section:primitive_types Primitive Types]

TODO Normal and uniform distributions of integral and floating point.

[endsect] [/ Primitive Types]

[section:sequences Ordered and Unordered Sequences]

TODO

[endsect] [/ Ordered and Unordered Sequences]

[section:class_types User-Defined Types]

TODO

[endsect] [/ User-Defined Types]

[endsect] [/ Generating Input]

[section:config_params Configuration Paramters]

TODO Describe _rng, _test_count, _max_test_count, and _sized.

[endsect] [/ Configuration Paramters]

[endsect] [/ Test Configuration]

[section:qcheck Running The Tests]

TODO

[section:qcheck The `qcheck` Algorithm]

TODO

[endsect] [/The `qcheck` Algorithm]

[section:qcheck Examining The Results]

TODO

[endsect] [/Examining The Results]

[endsect] [/Running The Tests]

[endsect] [/ Users' Guide]

[xinclude autodoc.xml]
