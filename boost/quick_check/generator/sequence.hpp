///////////////////////////////////////////////////////////////////////////////////////////////////
/// \file sequence.hpp
/// \brief Header that defines \c quick_check::sequence() and \c quick_check::ordered_sequence()
///        for declaring generators that create sequences.
//
// Copyright 2013 OptionMetrics, Inc.
// Copyright 2013 Eric Niebler
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying file
// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// NOTE: This library is not yet an official Boost library.
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef QCHK_GENERATOR_SEQUENCE_HPP_INCLUDED
#define QCHK_GENERATOR_SEQUENCE_HPP_INCLUDED

#include <cstddef>
#include <iterator>
#include <algorithm>
#include <boost/mpl/bool.hpp>
#include <boost/move/utility.hpp>
#include <boost/type_traits/is_convertible.hpp>
#include <boost/iterator/iterator_traits.hpp>
#include <boost/random/uniform_int_distribution.hpp>
#include <boost/quick_check/quick_check_fwd.hpp>
#include <boost/quick_check/generator/basic_generator.hpp>

QCHK_BOOST_NAMESPACE_BEGIN

namespace quick_check
{
    namespace detail
    {
#ifdef BOOST_NO_SFINAE_EXPR
        template<typename T, void (T::*)(typename T::size_type)>
        struct reserve_type
        {
            reserve_type(int);
        };

        template<typename U>
        mpl::true_ check_has_reserve(reserve_type<U, &U::reserve>);

        template<typename U>
        mpl::false_ check_has_reserve(...);

        template<typename T>
        struct has_reserve_impl
        {
            typedef decltype(detail::check_has_reserve<T>(1)) type;
        };

        template<typename T>
        struct has_reserve
          : has_reserve_impl<T>::type
        {};
#else
        template<typename T, typename Enable = void>
        struct has_reserve
          : mpl::false_
        {};

        template<typename T>
        struct has_reserve<T, decltype(boost::declval<T &>().reserve(1u))>
          : mpl::true_
        {};
#endif

        template<typename Seq, typename Gen>
        struct sequence_generator
        {
        private:
            typedef
                boost::random::uniform_int_distribution<std::size_t>
            size_dist_type;

            static_assert(
                boost::is_convertible<
                    typename Gen::result_type
                  , typename boost::iterator_value<
                        typename Seq::iterator
                    >::type
                >::value
              , "The values generated by the specified generator are not "
                "convertible to the specified container's element type."
            );

        public:
            typedef Seq result_type;

            explicit sequence_generator(Gen const &gen)
              : size_dist_(0,49)
              , gen_(gen)
            {}

            template<typename Rng>
            Seq operator()(Rng &rng)
            {
                std::size_t size = size_dist_(rng);
                result_type res;
                sequence_generator::reserve_(res, size, has_reserve<Seq>());
                std::generate_n(
                    std::back_inserter(res)
                  , size
                  , [&] { return gen_(rng); }
                );
                return boost::move(res);
            }

            friend void set_size(sequence_generator &thiz, std::size_t size)
            {
                BOOST_ASSERT(size >= 1);
                size_dist_type::param_type parm(0, size - 1);
                thiz.size_dist_.param(parm);
                detail::set_size_adl(thiz.gen_, size);
            }

        private:
            static void reserve_(Seq &, std::size_t size, mpl::false_)
            {}

            static void reserve_(Seq &seq, std::size_t size, mpl::true_)
            {
                seq.reserve(size);
            }

            size_dist_type size_dist_;
            Gen gen_;
        };

        template<typename Seq, typename Gen>
        struct ordered_sequence_generator
          : sequence_generator<Seq, Gen>
        {
        private:
            static_assert(
                boost::is_convertible<
                    typename boost::iterator_category<
                        typename Seq::iterator
                    >::type
                  , std::random_access_iterator_tag
                >::value
              , "The specified sequence does not have random-access iterators "
                "and cannot be sorted"
            );

        public:
            explicit ordered_sequence_generator(Gen const &gen)
              : sequence_generator<Seq, Gen>(gen)
            {}

            template<typename Rng>
            Seq operator()(Rng &rng)
            {
                Seq seq = static_cast<sequence_generator<Seq, Gen> &>(*this)(rng);
                std::sort(seq.begin(), seq.end());
                return boost::move(seq);
            }
        };
    }

    /// \brief Create a generator for a specified sequence type.
    ///
    /// \param gen The generator used to generate the elements fot the vector.
    ///
    /// \pre The elements generated by \c gen are convertible to the element
    ///      type of the sequence.
    ///
    /// The size of the resulting sequence is controlled by the \c quick_check::_sized
    /// named parameter to the \c quick_check::make_config() function, or by calling
    /// \c quick_check::config::sized() on the \c config\<\> object that
    /// \c quick_check::make_config() returns.
    ///
    /// \sa \c quick_check::ordered_vector
    /// \sa \c quick_check::_sized
    /// \sa \c quick_check::config::sized
    template<typename Seq, typename Gen>
    detail::sequence_generator<Seq, Gen>
    sequence(Gen const &gen)
    {
        return detail::sequence_generator<Seq, Gen>(gen);
    }

    /// \brief Create a generator for sorted sequences of objects.
    ///
    /// \param gen The generator used to generate the elements fot the sequence.
    ///
    /// \pre The elements generated by \c gen are convertible to the element
    ///      type of the sequence.
    ///
    /// \pre \c Gen::result_type is a type which has a partial order over the
    ///      \< operator.
    ///
    /// \pre The sequence's iterator type is a model of RandomAccessIterator.
    ///
    /// The sequences generated by the returned object are guaranteed to be sorted.
    ///
    /// The size of the resulting sequence is controlled by the \c quick_check::_sized
    /// named parameter to the \c quick_check::make_config() function, or by calling
    /// \c quick_check::config::sized() on the \c config\<\> object that
    /// \c quick_check::make_config() returns.
    ///
    /// \sa \c quick_check::vector
    /// \sa \c quick_check::_sized
    /// \sa \c quick_check::config::sized
    template<typename Seq, typename Gen>
    detail::ordered_sequence_generator<Seq, Gen>
    ordered_sequence(Gen const &gen)
    {
        return detail::ordered_sequence_generator<Seq, Gen>(gen);
    }
}

QCHK_BOOST_NAMESPACE_END

#endif
