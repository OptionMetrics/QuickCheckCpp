////////////////////////////////////////////////////////////////////////////////////////////////////
/// \file qcheck.hpp
/// \brief Definition of the \c quick_check::qcheck() algorithm
//
// Copyright 2013 OptionMetrics, Inc.
// Copyright 2013 Eric Niebler
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying file
// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// NOTE: This library is not yet an official Boost library.
////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef QCHK_QCHECK_HPP_INCLUDED
#define QCHK_QCHECK_HPP_INCLUDED

#include <boost/type_traits/remove_const.hpp>
#include <boost/type_traits/remove_reference.hpp>
#include <boost/move/utility.hpp>
#include <boost/quick_check/quick_check_fwd.hpp>
#include <boost/quick_check/qcheck_results.hpp>
#include <boost/quick_check/classify.hpp>
#include <boost/fusion/functional/invocation/invoke_function_object.hpp>
#include <boost/fusion/container/vector/convert.hpp>
#include <boost/fusion/algorithm/transformation/transform.hpp>
#include <boost/fusion/sequence/intrinsic/value_at.hpp>
#include <boost/fusion/sequence/intrinsic/size.hpp>
#include <boost/preprocessor/repetition/enum_params.hpp>
#include <boost/quick_check/detail/array.hpp>
#include <boost/quick_check/detail/grammar.hpp>
#include <boost/quick_check/classify.hpp>
#include <boost/quick_check/group_by.hpp>
#include <boost/quick_check/condition.hpp>

QCHK_BOOST_NAMESPACE_BEGIN

namespace quick_check
{
    namespace detail
    {
        struct GetPropertyFromCombinatorExpr
          : proto::or_<
                proto::when<
                    proto::bitwise_or<Combinators, phoenix::meta_grammar>
                  , proto::_right
                >
              , proto::otherwise<
                    proto::_
                >
            >
        {};

        struct GetProperty
          : proto::or_<
                proto::when<
                    ConditionalExpr
                  , GetPropertyFromCombinatorExpr(proto::_right)
                >
              , proto::otherwise<
                    GetPropertyFromCombinatorExpr
                >
            >
        {};

        template<typename Expr>
        typename boost::lazy_enable_if<
            proto::is_expr<Expr>
          , boost::result_of<detail::GetProperty(Expr const &)>
        >::type
        get_property(Expr const &prop)
        {
            static_assert(
                proto::matches<Expr, QuickCheckExpr>::value
              , "The specified quick-check expression does not match the grammar for "
                "valid quick-check expressions."
            );
            return detail::GetProperty()(prop);
        }

#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(QCHK_DOXYGEN_INVOKED)
        template<typename ...As>
        property<As...> const &
        get_property(property<As...> const &prop)
        {
            return prop;
        }
#else
        template<BOOST_PP_ENUM_PARAMS(QCHK_MAX_ARITY, typename A)>
        property<BOOST_PP_ENUM_PARAMS(QCHK_MAX_ARITY, A)> const &
        get_property(property<BOOST_PP_ENUM_PARAMS(QCHK_MAX_ARITY, A)> const &prop)
        {
            return prop;
        }
#endif

        struct qcheck_access
        {
            template<typename QchkResults, typename Args, typename Group>
            static void add_failure(
                QchkResults &results
              , Args const &args
              , std::vector<std::string> const &classes
              , Group const &group
            )
            {
                results.add_failure(args, classes, group);
            }

            template<typename QchkResults, typename Group>
            static void add_success(
                QchkResults &results
              , std::vector<std::string> const &classes
              , Group const &group
            )
            {
                results.add_success(classes, group);
            }

            template<typename QchkResults>
            static void set_exhausted(QchkResults &results)
            {
                results.set_exhausted();
            }
        };

        template<typename Property, typename Config>
        struct get_group_by_type
        {
            typedef
                typename boost::remove_const<
                    typename boost::remove_reference<
                        decltype(
                            detail::get_grouper(
                                boost::declval<Property const &>()
                            )(boost::declval<Config &>()())
                        )
                    >::type
                >::type
            type;
        };
    }

    /// \brief Check that the specified property hold true for all the
    ///        sets of arguments generated by the specified config. 
    ///
    /// The \c qcheck() algorithm is the algorithm that actually evaluates
    /// the property, looking for test failures. It uses the config both
    /// to generate input arguments and to specify how many tests should be
    /// run.
    ///
    /// The algorithm executed by \c qcheck() is described below:
    ///
    /// \li If \c sized is specified, then \c qcheck() first calls
    /// \c config.resized(sized).
    ///
    /// \li Sets of arguments are generated one at a time by invoking the \c config
    /// nullary function, for a maximum of \c config.max_test_count() times (see 
    /// \c config::max_test_count()).
    ///
    /// \li The arguments are passed to the property's condition predicate (see,
    /// for example, \c property::condition()). If it evaluates to false, the
    /// arguments are discarded, and a new set is generated. Otherwise, the
    /// arguments are passed to the \c prop predicate. This happens no
    /// more than \c config.test_count() times.
    ///
    /// \li If the property returns true, a success is recorded in a object of
    /// type \c qcheck_results<>. Otherwise, a failure is recorded.
    ///
    /// \li In addition, the arguments are classified and grouped according to
    /// the property's classifier and grouper (see, for example,
    /// \c property::classifier() and \c property::grouper()). These
    /// classifications and grouping are also recorded in the results object.
    ///
    /// \li Finally, after all tests have been run, \c qcheck() notes which limit
    /// was reached first, \c config.test_count() or \c config.max_test_count().
    /// If \c config.max_test_count() was reached first, it notes that the
    /// input was exhausted before the test completed. This state can be queried
    /// later with \c qcheck_results::exhausted().
    ///
    /// The \c qcheck() algorithm is perhaps more easily understood in terms
    /// of the following pseudo-code:
    ///
    /*! \code
        size_t n=0, total=0;
        qcheck_results<...> results;
        for(; n < config.test_count() &&
                total < config.max_test_count();
              ++total)
        {
            auto args = config(); // generate random args
            // Skip this if it is an invalid set of arguments
            if(!prop.condition()(args)) continue;
            ++n; // ok, we've got a valid set of arguments
            // Unpack args from tuple and evaluate the property
            if(!prop(args...))
                Add a failure to the results object
            else
                Add a success to the results object
        }
        if(n != config.test_count())
            Record in the results object that we exhausted input
        return results;
        \endcode
    */
    ///
    /// \em Example:
    ///
    /*! \code
        uniform<int> di(1,6);
        normal<double> dd(0.0, 1.0);
        auto config = make_config(_1 = di, _2 = dd);

        auto is_reflexive =
            classify(_2>0.,"foo")
          | classify(_2<=0.,"bar")
          | ((_1 + _2) == (_2 + _1));
 
        // Evaluate the property with the specified config.
        qcheck_results<int, double> res =
            qcheck(is_reflexive, config);

        // Print the summary to std::cout
        res.print_summary();
        \endcode
    */
    ///
    /// The above code displays the following:
    ///
    /*! \code
        OK, passed 100 tests.
        58% bar.
        42% foo.
        \endcode
    */
    ///
    /// \param prop The property to test.
    /// \param config An instance of \c config<>.
    /// \param sized A value that bounds the size of sequences
    ///              generated by \c config.
    ///
    /// \pre \c Property is either an instance of \c property<> or
    ///      a valid QuickCheckCpp property expression.
    /// \pre \c Config is an instance of \c config<>.
    /// \pre If \c Property is an instance of \c property<>, then
    ///      \c Config::result_type must be convertible to
    ///      \c Property::args_type.
    ///
    /// \return An instance of \c qcheck_results<> that holds the results
    ///         of this \c qcheck() invocation, including whether the test
    ///         passed or failed, and which sets of arguements caused the
    ///         test to fail, if any.
    template<typename Property, typename Config>
    typename detail::make_qcheck_results_type<
        typename Config::result_type
      , typename detail::get_group_by_type<Property, Config>::type
    >::type
    qcheck(Property const &prop, Config &config, std::size_t sized)
    {
        config.resized(sized);
        return boost::move(quick_check::qcheck(prop, config));
    }

    /// \overload
    ///
    template<typename Property, typename Config>
    typename detail::make_qcheck_results_type<
        typename Config::result_type
      , typename detail::get_group_by_type<Property, Config>::type
    >::type
    qcheck(Property const &prop, Config &config)
    {
        typedef
            typename detail::make_qcheck_results_type<
                typename Config::result_type
              , typename detail::get_group_by_type<Property, Config>::type
            >::type
        results_type;

        results_type results;

        auto const &prop_ = detail::get_property(prop);
        auto const &classify = detail::get_classifier(prop);
        auto const &groupby = detail::get_grouper(prop);
        auto const &condition = detail::get_condition(prop);

        std::size_t n = 0, total = 0;
        for(; n < config.test_count() && total < config.max_test_count(); ++total)
        {
            auto args = config();

            // Skip this if it is an invalid set of arguments
            if(!static_cast<bool>(condition(args)))
                continue;

            ++n; // ok, we've got a valid set of arguments
            auto classes = classify(args);
            auto group = groupby(args);

            // The static_cast here is mostly historical, but left here for
            // the sake of strictness.
            if(!static_cast<bool>(fusion::invoke_function_object(prop_, args)))
            {
                detail::qcheck_access::add_failure(
                    results
                  , fusion::as_vector(fusion::transform(args, detail::unpack_array()))
                  , std::move(classes)
                  , std::move(group)
                );
            }
            else
            {
                detail::qcheck_access::add_success(
                    results
                  , std::move(classes)
                  , std::move(group)
                );
            }
        }

        // Record whether we had to bail early.
        if(n != config.test_count())
            detail::qcheck_access::set_exhausted(results);

        return boost::move(results);
    }
}

QCHK_BOOST_NAMESPACE_END

#endif
